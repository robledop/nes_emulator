#include "cpu.h"
#include <stdio.h>
#include "memory.h"

// https://www.nesdev.org/obelisk-6502-guide/reference.html

static void handle_lda_flags(cpu* cpu)
{
	if (cpu->A & 0b10000000)
	{
		cpu_set_N_flag(cpu, 1);
	}

	if (cpu->A == 0)
	{
		cpu_set_Z_flag(cpu, 1);
	}
}

static void handle_ldx_flags(cpu* cpu)
{
	if (cpu->X & 0b10000000)
	{
		cpu_set_N_flag(cpu, 1);
	}

	if (cpu->X == 0)
	{
		cpu_set_Z_flag(cpu, 1);
	}
}

void cpu_exec(cpu* cpu, const byte instruction)
{
	switch (instruction)
	{
		///////////////////////////////////////////////////////////////////
		// ! LDA opcodes
		///////////////////////////////////////////////////////////////////
		// https://www.nesdev.org/obelisk-6502-guide/reference.html#LDA

		// LDA immediate
		// LDA #10         ;Load 10 ($0A) into the accumulator
		// https://www.nesdev.org/obelisk-6502-guide/addressing.html#IMM
		case 0xA9:
			cpu->PC++;
			cpu->A = cpu->memory.data[cpu->PC];
			handle_lda_flags(cpu);
			break;

			// LDA Zero Page
			// LDA $00         ;Load accumulator from $00
			// https://www.nesdev.org/obelisk-6502-guide/addressing.html#ZPG
		case 0xA5:
			cpu->PC++;
			cpu->A = cpu->memory.data[cpu->memory.data[cpu->PC]];
			handle_lda_flags(cpu);
			break;

			// LDA Zero Page,X
			// LDA $10,X       ;Load accumulator from location 10 + X
			// https://www.nesdev.org/obelisk-6502-guide/addressing.html#ZPX
		case 0xB5:
		{
			cpu->PC++;
			const word address = cpu->memory.data[cpu->PC] + cpu->X;
			cpu->A = cpu->memory.data[address];
			handle_lda_flags(cpu);
		}
		break;

		// LDA Absolute
		// LDA $1234       ;Load accumulator from location $1234
		// https://www.nesdev.org/obelisk-6502-guide/addressing.html#ABS
		case 0xAD:
		{
			cpu->PC++;
			const byte low_byte = cpu->memory.data[cpu->PC];
			cpu->PC++;
			const byte high_byte = cpu->memory.data[cpu->PC];
			const word address = ((word)(high_byte << 8)) | low_byte;
			cpu->A = cpu->memory.data[address];
			handle_lda_flags(cpu);
		}
		break;

		// LDA Absolute,X
		// LDA $3000,X     ;Load accumulator  $3000 + X
		// https://www.nesdev.org/obelisk-6502-guide/addressing.html#ABX
		case 0xBD:
		{
			cpu->PC++;
			const byte low_byte = cpu->memory.data[cpu->PC];
			cpu->PC++;
			const byte high_byte = cpu->memory.data[cpu->PC];
			word address = ((word)(high_byte << 8)) | low_byte;
			address += cpu->X;
			cpu->A = cpu->memory.data[address];
			handle_lda_flags(cpu);
		}
		break;

		// LDA Absolute,Y
		// LDA $3000,Y     ;Load accumulator  $3000 + Y
		// https://www.nesdev.org/obelisk-6502-guide/addressing.html#ABY
		case 0xB9:
		{
			cpu->PC++;
			const byte low_byte = cpu->memory.data[cpu->PC];
			cpu->PC++;
			const byte high_byte = cpu->memory.data[cpu->PC];
			word address = ((word)(high_byte << 8)) | low_byte;
			address += cpu->Y;
			cpu->A = cpu->memory.data[address];
			handle_lda_flags(cpu);
		}
		break;

		// LDA (Indirect,X)
		// LDA ($40,X)     ;Load a byte indirectly from memory
		// https://www.c64-wiki.com/wiki/Indexed-indirect_addressing
		case 0xA1:
		{
			cpu->PC++;
			const byte vector = cpu->memory.data[cpu->PC] + cpu->X;

			const byte low_byte = cpu->memory.data[vector];
			const byte high_byte = cpu->memory.data[vector + 1];
			const word address = ((word)(high_byte << 8)) | low_byte;
			cpu->A = cpu->memory.data[address];
			handle_lda_flags(cpu);
		}
		break;

		// LDA (Indirect),Y
		// LDA ($40),Y     ;Load a byte indirectly from memory
		// https://www.c64-wiki.com/wiki/Indirect-indexed_addressing
		case 0xB1:
		{
			// TODO: check if the PC is supposed to be incremented more than once
			cpu->PC++;
			const byte vector = cpu->memory.data[cpu->PC];

			const byte low_byte = cpu->memory.data[vector];
			const byte high_byte = cpu->memory.data[vector + 1];

			word address = ((word)(high_byte << 8)) | low_byte;
			address += cpu->Y;

			cpu->A = cpu->memory.data[address];
			handle_lda_flags(cpu);
		}
		break;

		///////////////////////////////////////////////////////////////////
		// ! LDX opcodes
		///////////////////////////////////////////////////////////////////

		case 0xA2:
			break;

		case 0xA6:
			break;

		case 0xB6:
			break;

		case 0xAE:
			break;

		case 0xBE:
			break;

		///////////////////////////////////////////////////////////////////
		// ! LDY opcodes
		///////////////////////////////////////////////////////////////////

		case 0xA0:
			break;

		case 0xA4:
			break;

		case 0xB4:
			break;

		case 0xAC:
			break;

		case 0xBC:
			break;

		///////////////////////////////////////////////////////////////////
		// ! ADC opcodes
		///////////////////////////////////////////////////////////////////

		case 0x69:
			break;

		case 0x65:
			break;

		case 0x75:
			break;

		case 0x6D:
			break;

		case 0x7D:
			break;
		case 0x79:
			break;
		case 0x61:
			break;
		case 0x71:
			break;

		///////////////////////////////////////////////////////////////////
		// ! AND opcodes
		///////////////////////////////////////////////////////////////////

		case 0x29:
			break;
		case 0x25:
			break;
		case 0x35:
			break;
		case 0x2D:
			break;
		case 0x3D:
			break;
		case 0x39:
			break;
		case 0x21:
			break;
		case 0x31:
			break;

		///////////////////////////////////////////////////////////////////
		// ! ASL opcodes
		///////////////////////////////////////////////////////////////////

		case 0x0A:
			break;
		case 0x06:
			break;
		case 0x16:
			break;
		case 0x0E:
			break;
		case 0x1E:
			break;

		///////////////////////////////////////////////////////////////////
		// ! BCC opcodes
		///////////////////////////////////////////////////////////////////

		case 0x90:
			break;

		///////////////////////////////////////////////////////////////////
		// ! BCS opcodes
		///////////////////////////////////////////////////////////////////

		case 0xB0:
			break;

		///////////////////////////////////////////////////////////////////
		// ! BEQ opcodes
		///////////////////////////////////////////////////////////////////

		case 0xF0:
			break;

		///////////////////////////////////////////////////////////////////
		// ! BIT opcodes
		///////////////////////////////////////////////////////////////////

		case 0x24:
			break;
		case 0x2C:
			break;

		///////////////////////////////////////////////////////////////////
		// ! BMI opcodes
		///////////////////////////////////////////////////////////////////

		case 0x30:
			break;

		///////////////////////////////////////////////////////////////////
		// ! BNE opcodes
		///////////////////////////////////////////////////////////////////

		case 0xD0:
			break;

		///////////////////////////////////////////////////////////////////
		// ! BPL opcodes
		///////////////////////////////////////////////////////////////////

		case 0x10:
			break;

		///////////////////////////////////////////////////////////////////
		// ! BRK opcodes
		///////////////////////////////////////////////////////////////////

		case 0x00:
			break;

		///////////////////////////////////////////////////////////////////
		// ! BVC opcodes
		///////////////////////////////////////////////////////////////////

		case 0x50:
			break;

		///////////////////////////////////////////////////////////////////
		// ! BVS opcodes
		///////////////////////////////////////////////////////////////////

		case 0x70:
			break;

		///////////////////////////////////////////////////////////////////
		// ! CLC opcodes
		///////////////////////////////////////////////////////////////////

		case 0x18:
			break;

		///////////////////////////////////////////////////////////////////
		// ! CLD opcodes
		///////////////////////////////////////////////////////////////////

		case 0xd8:
			break;

		///////////////////////////////////////////////////////////////////
		// ! CLI opcodes
		///////////////////////////////////////////////////////////////////

		case 0x58:
			break;

		///////////////////////////////////////////////////////////////////
		// ! CLV opcodes
		///////////////////////////////////////////////////////////////////

		case 0xB8:
			break;

		///////////////////////////////////////////////////////////////////
		// ! CMP opcodes
		///////////////////////////////////////////////////////////////////

		case 0xC9:
			break;
		case 0xC5:
			break;
		case 0xD5:
			break;
		case 0xCD:
			break;
		case 0xDD:
			break;
		case 0xD9:
			break;
		case 0xC1:
			break;
		case 0xD1:
			break;

		///////////////////////////////////////////////////////////////////
		// ! CPX opcodes
		///////////////////////////////////////////////////////////////////

		case 0xE0:
			break;
		case 0xE4:
			break;
		case 0xEC:
			break;

		///////////////////////////////////////////////////////////////////
		// ! CPY opcodes
		///////////////////////////////////////////////////////////////////

		case 0xC0:
			break;
		case 0xC4:
			break;
		case 0xCC:
			break;

		///////////////////////////////////////////////////////////////////
		// ! DEC opcodes
		///////////////////////////////////////////////////////////////////

		case 0xC6:
			break;
		case 0xD6:
			break;
		case 0xCE:
			break;
		case 0xDE:
			break;

		///////////////////////////////////////////////////////////////////
		// ! DEX opcodes
		///////////////////////////////////////////////////////////////////

		case 0xCA:
			break;

		///////////////////////////////////////////////////////////////////
		// ! CEY opcodes
		///////////////////////////////////////////////////////////////////

		case 0x88:
			break;

		///////////////////////////////////////////////////////////////////
		// ! EOR opcodes
		///////////////////////////////////////////////////////////////////

		case 0x49:
			break;
		case 0x45:
			break;
		case 0x55:
			break;
		case 0x4D:
			break;
		case 0x5D:
			break;
		case 0x59:
			break;
		case 0x41:
			break;
		case 0x51:
			break;

		///////////////////////////////////////////////////////////////////
		// ! INC opcodes
		///////////////////////////////////////////////////////////////////

		case 0xE6:
			break;
		case 0xF6:
			break;
		case 0xEE:
			break;
		case 0xFE:
			break;

		///////////////////////////////////////////////////////////////////
		// ! INX opcodes
		///////////////////////////////////////////////////////////////////

		case 0xE8:
			break;

		///////////////////////////////////////////////////////////////////
		// ! INY opcodes
		///////////////////////////////////////////////////////////////////

		case 0xC8:
			break;

		///////////////////////////////////////////////////////////////////
		// ! JMP opcodes
		///////////////////////////////////////////////////////////////////

		case 0x4C:
			break;
		case 0x6C:
			break;

		///////////////////////////////////////////////////////////////////
		// ! JSR opcodes
		///////////////////////////////////////////////////////////////////

		case 0x20:
			break;

		///////////////////////////////////////////////////////////////////
		// ! LSR opcodes
		///////////////////////////////////////////////////////////////////

		case 0x4A:
			break;
		case 0x46:
			break;
		case 0x56:
			break;
		case 0x4E:
			break;
		case 0x5E:
			break;

		///////////////////////////////////////////////////////////////////
		// ! NOP opcodes
		///////////////////////////////////////////////////////////////////

		case 0xEA:
			break;

		///////////////////////////////////////////////////////////////////
		// ! ORA opcodes
		///////////////////////////////////////////////////////////////////

		case 0x09:
			break;
		case 0x05:
			break;
		case 0x15:
			break;
		case 0x0D:
			break;
		case 0x1D:
			break;
		case 0x19:
			break;
		case 0x01:
			break;
		case 0x11:
			break;

		///////////////////////////////////////////////////////////////////
		// ! PHA opcodes
		///////////////////////////////////////////////////////////////////

		case 0x48:
			break;

		///////////////////////////////////////////////////////////////////
		// ! PHP opcodes
		///////////////////////////////////////////////////////////////////

		case 0x08:
			break;

		///////////////////////////////////////////////////////////////////
		// ! PLA opcodes
		///////////////////////////////////////////////////////////////////

		case 0x68:
			break;

		///////////////////////////////////////////////////////////////////
		// ! PLP opcodes
		///////////////////////////////////////////////////////////////////

		case 0x28:
			break;

		///////////////////////////////////////////////////////////////////
		// ! ROL opcodes
		///////////////////////////////////////////////////////////////////

		case 0x2A:
			break;
		case 0x26:
			break;
		case 0x36:
			break;
		case 0x2E:
			break;
		case 0x3E:
			break;

		///////////////////////////////////////////////////////////////////
		// ! ROR opcodes
		///////////////////////////////////////////////////////////////////

		case 0x6A:
			break;
		case 0x66:
			break;
		case 0x76:
			break;
		case 0x6E:
			break;
		case 0x7E:
			break;

		///////////////////////////////////////////////////////////////////
		// ! RTI opcodes
		///////////////////////////////////////////////////////////////////

		case 0x40:
			break;

		///////////////////////////////////////////////////////////////////
		// ! RTS opcodes
		///////////////////////////////////////////////////////////////////

		case 0x60:
			break;

		///////////////////////////////////////////////////////////////////
		// ! SBC opcodes
		///////////////////////////////////////////////////////////////////

		case 0xE9:
			break;
		case 0xE5:
			break;
		case 0xF5:
			break;
		case 0xED:
			break;
		case 0xFD:
			break;
		case 0xF9:
			break;
		case 0xE1:
			break;
		case 0xF1:
			break;

		///////////////////////////////////////////////////////////////////
		// ! SEC opcodes
		///////////////////////////////////////////////////////////////////

		case 0x38:
			break;

		///////////////////////////////////////////////////////////////////
		// ! SED opcodes
		///////////////////////////////////////////////////////////////////

		case 0xF8:
			break;

		///////////////////////////////////////////////////////////////////
		// ! SEI opcodes
		///////////////////////////////////////////////////////////////////

		case 0x78:
			break;

		///////////////////////////////////////////////////////////////////
		// ! STA opcodes
		///////////////////////////////////////////////////////////////////

		case 0x85:
			break;
		case 0x95:
			break;
		case 0x8D:
			break;
		case 0x9D:
			break;
		case 0x99:
			break;
		case 0x81:
			break;
		case 0x91:
			break;

		///////////////////////////////////////////////////////////////////
		// ! STX opcodes
		///////////////////////////////////////////////////////////////////

		case 0x86:
			break;
		case 0x96:
			break;
		case 0x8E:
			break;

		///////////////////////////////////////////////////////////////////
		// ! STY opcodes
		///////////////////////////////////////////////////////////////////

		case 0x84:
			break;
		case 0x94:
			break;
		case 0x8C:

		///////////////////////////////////////////////////////////////////
		// ! TAX opcodes
		///////////////////////////////////////////////////////////////////

		case 0xAA:
			break;

		///////////////////////////////////////////////////////////////////
		// ! TAY opcodes
		///////////////////////////////////////////////////////////////////

		case 0xA8:
			break;

		///////////////////////////////////////////////////////////////////
		// ! TSX opcodes
		///////////////////////////////////////////////////////////////////

		case 0xBA:
			break;

		///////////////////////////////////////////////////////////////////
		// ! TXA opcodes
		///////////////////////////////////////////////////////////////////

		case 0x8A:
			break;

		///////////////////////////////////////////////////////////////////
		// ! TXS opcodes
		///////////////////////////////////////////////////////////////////

		case 0x9A:
			break;


		///////////////////////////////////////////////////////////////////
		// ! TYA opcodes
		///////////////////////////////////////////////////////////////////

		case 0x98:
			break;

		default:
			printf("%s", "Unsupported opcode");
	}
}

void cpu_clear_memory(cpu* cpu)
{
	memset(&cpu->memory, 0, MAX_MEMORY);
}

void cpu_init(cpu* cpu)
{
	cpu->SP = 0xFF;
	cpu->P = 0x00;
	cpu->A = 0x00;
	cpu->X = 0x00;
	cpu->Y = 0x00;
	cpu->PC = ((word)(cpu->memory.data[0xFFFD] << 8)) | cpu->memory.data[0xFFFC];
}

bool cpu_get_C_flag(const cpu* cpu)
{
	return cpu->P & 0b00000001;
}

bool cpu_get_Z_flag(const cpu* cpu)
{
	return cpu->P & 0b00000010;
}

bool cpu_get_I_flag(const cpu* cpu)
{
	return cpu->P & 0b00000100;
}

bool cpu_get_D_flag(const cpu* cpu)
{
	return cpu->P & 0b00001000;
}

bool cpu_get_B_flag(const cpu* cpu)
{
	return cpu->P & 0b00010000;
}

bool cpu_get_V_flag(const cpu* cpu)
{
	return cpu->P & 0b00100000;
}

bool cpu_get_N_flag(const cpu* cpu)
{
	return cpu->P & 0b10000000;
}


void cpu_set_C_flag(cpu* cpu, const char val)
{
	cpu->P ^= (-val ^ cpu->P) & (1UL << 0);
}

void cpu_set_Z_flag(cpu* cpu, const char val)
{
	cpu->P ^= (-val ^ cpu->P) & (1UL << 1);
}

void cpu_set_I_flag(cpu* cpu, const char val)
{
	cpu->P ^= (-val ^ cpu->P) & (1UL << 2);
}

void cpu_set_D_flag(cpu* cpu, const char val)
{
	cpu->P ^= (-val ^ cpu->P) & (1UL << 3);
}

void cpu_set_B_flag(cpu* cpu, const char val)
{
	cpu->P ^= (-val ^ cpu->P) & (1UL << 4);
}

void cpu_set_V_flag(cpu* cpu, const char val)
{
	cpu->P ^= (-val ^ cpu->P) & (1UL << 6);
}

void cpu_set_N_flag(cpu* cpu, const char val)
{
	cpu->P ^= (-val ^ cpu->P) & (1UL << 7);
}